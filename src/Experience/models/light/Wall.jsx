/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 Light_Third.glb 
*/

import React, { useEffect, useState, useRef, useMemo, useCallback } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from 'three';
import { clone } from '../../SkeletonUtils';

// ✅ GLOBAL
const textureLoader = new THREE.TextureLoader();

function buildThreeMaterial(cfg) {
  const params = {};
  if (cfg.map) {
    const map = textureLoader.load(cfg.map);
    map.colorSpace = THREE.SRGBColorSpace;
    map.repeat.set(1, 1);  // ✅ TILING 1x1x1
    map.wrapS = map.wrapT = THREE.RepeatWrapping;
    params.map = map;
    // params.map = textureLoader.load(cfg.map);
    params.map.colorSpace = THREE.SRGBColorSpace;
  }
  if (cfg.normalMap) params.normalMap = textureLoader.load(cfg.normalMap);
  if (cfg.roughnessMap) params.roughnessMap = textureLoader.load(cfg.roughnessMap);
  if (typeof cfg.metalness === 'number') params.metalness = cfg.metalness;
  if (typeof cfg.roughness === 'number') params.roughness = cfg.roughness;
  const MatClass = THREE[cfg.type] || THREE.MeshPhysicalMaterial;
  return new MatClass(params);
}

// ✅ Cube Component với UVW 1x1x1 (5x3.6x1)
function CubeGeo({ mtl, ...props }) {
  const meshRef = useRef();

  function scaleUV(baseUV, scaleU, scaleV, offset, targetArray) {
    for (let i = 0; i < 8; i += 2) {
      targetArray[offset + i] = baseUV[i] * scaleU;     // U coord
      targetArray[offset + i + 1] = baseUV[i + 1] * scaleV; // V coord
    }
  }

  const cubeGeometry = useMemo(() => {
    const geo = new THREE.BoxGeometry(props.width, props.height, props.length);
    
    let [WIDTH,HEIGHT,DEPTH] = props.uvs;   // X direction
    WIDTH /= mtl.matscale;
    HEIGHT /= mtl.matscale;
    DEPTH /= mtl.matscale ;
    // console.log(WIDTH,HEIGHT,DEPTH);
    
    // UV gốc của bạn [0,1, 1,1, 0,0, 1,0]
    const baseUV = [0, 1, 1, 1, 0, 0, 1, 0];
    
    // ✅ Áp dụng scale cho 6 faces
    const scaledUVs = new Float32Array(48);
    
    // Face 0: +Z (front) - scale theo WIDTH x HEIGHT
    scaleUV(baseUV, WIDTH, HEIGHT, 0, scaledUVs);
    
    // Face 1: -Z (back) - scale theo WIDTH x HEIGHT  
    scaleUV(baseUV, WIDTH, HEIGHT, 8, scaledUVs);
    
    // Face 2: +X (right) - scale theo DEPTH x HEIGHT
    scaleUV(baseUV, DEPTH, HEIGHT, 16, scaledUVs);
    
    // Face 3: -X (left) - scale theo DEPTH x HEIGHT
    scaleUV(baseUV, DEPTH, HEIGHT, 24, scaledUVs);
    
    // Face 4: +Y (top) - scale theo WIDTH x DEPTH
    scaleUV(baseUV, WIDTH, DEPTH, 32, scaledUVs);
    
    // Face 5: -Y (bottom) - scale theo WIDTH x DEPTH
    scaleUV(baseUV, WIDTH, DEPTH, 40, scaledUVs);

    geo.setAttribute('uv', new THREE.BufferAttribute(scaledUVs, 2));
    return geo;
  }, []);

  const cubeMaterial = useMemo(() => {
    if (!mtl) {
      return new THREE.MeshPhysicalMaterial({
        color: 0xcccccc, metalness: 0.5, roughness: 0.5
      });
    }
    return buildThreeMaterial(mtl);
  }, [mtl]);

  return (
    <>
      <mesh ref={meshRef} dispose={null} position={[0,  props.height / 2,0]}>
        <primitive object={cubeGeometry} attach="geometry" />
        <primitive object={cubeMaterial} attach="material" />
      </mesh>
    </>
  );
}

export default function Model(props) {
  const { mtl, ...rest } = props;
  const { scene } = useGLTF('/models/NewRoom/wall.glb');
  const groupRef = useRef();
  
  
  return (
    <group ref={groupRef} {...rest} dispose={null}>
      {/* ✅ Thay thế hoàn toàn scene bằng Cube 5x3.6x1 */}
      <CubeGeo mtl={mtl} {...props}/>
    </group>
  );
}
